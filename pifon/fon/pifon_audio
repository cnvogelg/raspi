#!/usr/bin/env python3
#
# pifon_audio
#
# detect intervals ouf loudness and generate events
# uses SoX' rec tool with ALSA driver for USB WebCam audio
#

import os
import sys
import inspect

# add ../../tools to python path
my_dir = os.path.split(inspect.getfile( inspect.currentframe() ))[0]
tools_dir = os.path.realpath(os.path.abspath(os.path.join(my_dir,"..","..","tools")))
if tools_dir not in sys.path:
  sys.path.insert(0, tools_dir)

import botio
import botopts
from botoptfield import BotOptField

import detector
import recorder
import simulator

# ----- Options -----

listen_url = 'http://your_server.com:8000/pifon.m3u'
src_name = 'Maja+Willi'

opts = [
  BotOptField('sim', bool, False, desc='enable level simulator'),
  BotOptField('trace', bool, False, desc='enable level tracing'),
  BotOptField('listen_url', str, listen_url, desc='url of audio stream'),
  BotOptField('src_name', str, src_name, desc='name of audio source'),
  BotOptField('alevel', int, 1, val_range=[1,100], desc='audio level to reach in attack phase [1-100]'),
  BotOptField('slevel', int, 1, val_range=[1,100], desc='audio level to stay below in sustain phase [1-100]'),
  BotOptField('attack', int, 0, val_range=[1,10], desc='period [1s] of loudness required to start playback'),
  BotOptField('sustain', int, 5, val_range=[0,60], desc='period [1s] of silence required to stop playback'),
  BotOptField('respite', int, 10, val_range=[0,60], desc='delay [1s] after playback to wait for next'),
  BotOptField('update', int, 5, val_range=[1,60], desc='update interval of current peak level [100ms]')
]

def_cfg = {
  'sample_rate' : 11025,
  'channels' : 1,
  'interval' : 250,
  'recorder' : 'auto'
}

# ----- Event Handler -----

class DetectorEventHandler:
  def __init__(self, botio, bopts):
    self.botio = botio
    self.bopts = bopts
    self.first = True

  def state(self, state):
    # send source info before attack
    if state == 'attack' or self.first:
      name = self.bopts.get_value('src_name')
      url = self.bopts.get_value('listen_url')
      self.botio.write_line("audio_src %s %s" % (name, url))
      self.first = False
    # write audio_state
    self.botio.write_line("audio_state %s" % state)

  def level(self, max_level, cur_level, duration):
    self.botio.write_line("audio_level %d %d %d" % (max_level, cur_level, duration))


def handle_msg(bio, msg, d):
  args = msg.args
  # answer pings
  if args[0] == 'audio_ping':
    bio.write_line('audio_pong', receivers=[msg.sender])
    return True
  # answer query audio state
  elif args[0] == 'query_audio_state':
    bio.write_line('audio_state '+ d.get_state_name(), receivers=[msg.sender])
    return True
  # unknown command
  else:
    return False

# ---------- main ----------

def main():

  # setup bot
  bio = botio.BotIO()
  nick = bio.get_nick()
  botcfg = bio.get_cfg()
  bopts = botopts.BotOpts(bio,opts,cfg=botcfg,cfg_name="audio")

  # get vumeter options
  vu_cfg = botcfg.get_section("vumeter", def_cfg)
  rec = vu_cfg['recorder']
  sample_rate = vu_cfg['sample_rate']
  channels = vu_cfg['channels']
  interval = vu_cfg['interval']

  # setup audio
  ev = DetectorEventHandler(bio, bopts)
  d = detector.Detector(bopts)
  rec = recorder.Recorder(sample_rate, interval, channels, rec)
  sim = simulator.Simulator()

  print("starting audio",file=sys.stderr)
  print("vumeter=",vu_cfg,file=sys.stderr)
  print("audio=",bopts.get_values(),file=sys.stderr)

  # ----- main loop -----
  try:
    while True:
      # process audio data
      rms = rec.read_rms()
      if rms is None:
        break
      # replace with sim data
      if bopts.get_value('sim'):
        rms = sim.read_rms()
        print("sim",rms,file=sys.stderr)
      # process rms value
      d.handle_rms(rms)

      # process bot messages
      msg = bio.read_args(timeout=0.0)
      if msg:
        if msg.is_internal:
          if msg.int_nick == nick:
            # my connect
            if msg.int_cmd == 'connected':
              print("connected",file=sys.stderr)
              d.set_event_handler(ev)
              ev.first = True
              d.post_state()
            elif msg.ind_cmd == 'disconnected':
              print("disconnected",file=sys.stderr)
              d.set_event_handler(None)
        else:
          ok = handle_msg(bio, msg, d)
          if not ok:
            bopts.handle_command(msg)
  except KeyboardInterrupt:
    print("\nbreak -> stopping audio",file=sys.stderr);

if __name__ == '__main__':
  main()
